import requests
from discord_webhook import DiscordWebhook
from datetime import datetime
import os
import json

RCE_WEBHOOK_URL = os.environ.get("RCE_WEBHOOK_URL")
CVE_ALERT_WEBHOOK_URL = os.environ.get("CVE_ALERT_WEBHOOK_URL")

with open("config.json", "r") as config_file:
    config = json.load(config_file)

RCE_WEBHOOK_URL = config["RCE_WEBHOOK_URL"]
CVE_ALERT_WEBHOOK_URL = config["CVE_ALERT_WEBHOOK_URL"]


# NVD API URL for fetching CVE data
CVE_API_URL = "https://services.nvd.nist.gov/rest/json/cves/1.0"
# Path to the file storing previously fetched CVE IDs
PREVIOUS_CVE_FILE = "previous.txt"

# Function to check if a CVE description contains any of the keywords
def has_keyword(description):
    matched_keywords = [keyword for keyword in KEYWORDS if keyword in description]
    print("Matched Keywords:", matched_keywords)
    return bool(matched_keywords)


# Function to fetch and process CVE data
def fetch_cve_data():
    try:
        response = requests.get(CVE_API_URL)
        response.raise_for_status()  # Raise an exception for 4xx or 5xx status codes
        cve_data = response.json()
        print("CVE API Response:", cve_data)

        notifications = []
        previous_cves = load_previous_cves()

        cve_items = cve_data.get('result', {}).get('CVE_Items', [])

        for cve_item in cve_items:
            cve_id = cve_item['cve']['CVE_data_meta']['ID']

            # Skip already fetched CVEs
            if cve_id in previous_cves:
                continue

            # Extract the year from the CVE ID
            cve_year = int(cve_id.split('-')[1])

            # Skip CVEs that are not from 2023
            if cve_year != 2023:
                continue

            description = cve_item['cve']['description']['description_data'][0]['value']
            published_date = cve_item['publishedDate']
            published_datetime = datetime.strptime(published_date, "%Y-%m-%dT%H:%MZ")
            cvss_score = cve_item['impact'].get('baseMetricV3', {}).get('cvssV3', {}).get('baseScore', 'N/A')

            # Save the new CVE ID to the file
            save_cve_id(cve_id)

            formatted_date = published_datetime.strftime("%d/%m/%Y")
            notification = f"\n**__New CVE Notification:__**\n" \
                           f"**CVE ID:** {cve_id}\n" \
                           f"**Published Date:** {formatted_date}\n" \
                           f"**CVSS Score:** {cvss_score}\n" \
                           f"**Description:** {description}\n\n\n"

            if has_keyword(description):
                webhook_url = RCE_WEBHOOK_URL
            else:
                webhook_url = CVE_ALERT_WEBHOOK_URL

            notifications.append((webhook_url, notification))  # Append tuple with webhook URL and notification

        return notifications

    except requests.exceptions.RequestException as e:
        print("Error fetching CVE data:", e)
        return []



# Load previously fetched CVE IDs from file
def load_previous_cves():
    try:
        with open(PREVIOUS_CVE_FILE, "r") as file:
            previous_cves = file.read().splitlines()
            return previous_cves
    except FileNotFoundError:
        return []


# Save the new CVE ID to the file
def save_cve_id(cve_id):
    with open(PREVIOUS_CVE_FILE, "a") as file:
        file.write(cve_id + "\n")


# Keywords for filtering CVEs
KEYWORDS = ["Remote Code Execution", "Arbitrary Code Execution", "RCE", "code injection","Code Injection", "RDP", "elastic", "SQL Injection" ]
# Fetch and send CVE notifications
cve_data = fetch_cve_data()


if cve_data:
    for webhook_url, notification in cve_data:
        webhook = DiscordWebhook(url=webhook_url, content=notification)
        print("Sending notification to webhook: [Webhook URL Hidden]")
        webhook.execute()
else:
    webhook = DiscordWebhook(url=CVE_ALERT_WEBHOOK_URL, content="\n\n\n**__No New CVE Found.__**\n\n\n")
    webhook.execute()
